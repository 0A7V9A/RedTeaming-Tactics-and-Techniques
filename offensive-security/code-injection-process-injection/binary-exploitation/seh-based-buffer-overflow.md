# SEH Based Buffer Overflow

The purpose of this lab is to familiarize how Structured Exception Handler / SEH based buffer overflow exploits work.

This lab is based on a blog post [The Basics of Exploit Development 2: SEH Overflows](https://www.coalfire.com/the-coalfire-blog/march-2020/the-basics-of-exploit-development-2-seh-overflows) by Andy Bowden.

{% hint style="info" %}
WIP
{% endhint %}

## SEH 101

* Structured exception handling \(SEH\) is simply code in a program that is meant to handles such situations when the program throws some exception either due to a hardware or software issue and do something to resolve it;
* SEH code is located on the program's stack for each `try-catch` code block and each handler has its own stack frame;
* SEH is stored in stack as `EXCEPTION_REGISTRATION` structure \(also called as SEH record\) consisting of two 4 byte fields:
  * pointer to the next SEH record within the SEH chain;
  * pointer to the exception handler code - the `catch` part of the code block;
* A program may have multiple SEHs registered that are connected by a linked list, forming a SEH chain;
  * Once a program throws an exception, the OS runs through the SEH chain and attempts to find an apropriate exception handler;
  * If no suitable handler is found, a default OS handler is used from the bottom of the SEH chain. All SEH chains always end with a default Windows SEH record located at `FFFFFFFF`;
* SEH chain is stored in the Thread Environment Block \(TEB\) memory structure as the first member called Thread Information Block \(TIB\) and can be accessed via FS segment register `FS:[0x00]`;
* 64-bit applications are not vulnerable to SEH overflow as binaries are linked with safe exception handlers embedded in the PE file itself.
* 32-bit applications can be linked with `/SAFESEH` flag, which will produce a PE file with a table of safe exception handlers, assuming all modules are compatible with safe execption handling feature.

Below is a simplified diagram visualising some of the key points outlined above:

![TEB, SEH Chains, SEH Records visualised](../../../.gitbook/assets/image%20%28974%29.png)

## Exploring TEB / TIB / SEH Chains

### Memory Structures

Let's explore the key structures around SEH using WinDBG and confirm the key points mentioned in the SEH 101 section.

Thread Environment Block is a described in the OS as `_TEB` memory structure and can be inspected in WinDBG like so: 

```text
dt _teb
```

![Snippet of the \_TEB memory structure](../../../.gitbook/assets/image%20%28973%29.png)

As seen from the above screenshot, the TEB's first member is `_NT_TIB` \(Thread Information Block\) memory structure, which can be inspected like so:

```text
dt _NT_TIB
```

![TIB memory structure in WinDBG](../../../.gitbook/assets/image%20%28975%29.png)

As mentioned earlier, the first member inside the `_NT_TIB` structure is a pointer to `_EXCEPTION_REGISTRATION_RECORD` memory structure, which is the first SEH record / head of the SEH Chain linked list and can be inspected like so:

```text
dt _EXCEPTION_REGISTRATION_RECORD
```

![SEH record memory structure \_EXCEPTION\_REGISTRATION\_RECORD ](../../../.gitbook/assets/image%20%28976%29.png)

The first member of `_EXCEPTION_REGISTRATION_RECORD` is a pointer to the next SEH record and the second member is a pointer to the exception handler that is defined in the `_EXCEPTION_DISPOSITION` memory structure.

### Actual Memory Structures

We've learned about a couple of key memory structures, but now let's see how those structures look like when inspecting a real program that has some SEH records defined. 

As noted earlier, SEH are the `try` / `catch` code blocks in the program as shown below:

{% code title="seh-overflow.c" %}
```c
int main(int argc, char* argv[]) 
{
    try
    {
        throw 1;
    }
    catch (int e)
    {
        
    }

    return 0;
}
```
{% endcode %}

Let's compile the above program as seh-overflow.exe and inspect it with WinDBG again, this time with a `!teb` command:

![!teb](../../../.gitbook/assets/image%20%28978%29.png)

We can see that `_TEB` is located at `00a25000` and that the `ExceptionList` / head of the SEH chain is located at `00cff2cc`. From earlier, we said that this value could also be retrieved from the FS segment register `fs:[0]`, so let's confirm that:

```text
dd fs:[0] L1
```

![SEH chain retrieved from fs:\[0\]](../../../.gitbook/assets/image%20%28971%29.png)

Let's check the start of the SEH chain at `00cff2cc` like so:

```text
dt _EXCEPTION_REGISTRATION_RECORD 00cff2cc
```

{% hint style="info" %}
From this point the`ExceptionList` address changed from `00cff2cc` to `00cff274` due to the restarted program. This may happen multiple time throughout the labs.
{% endhint %}

![Start of the SEH chain at 00cff274](../../../.gitbook/assets/image%20%28985%29.png)

Below gif demonstrates how we can get the address of the head of the SEH chain with `!teb` command and by inspecting the `ExceptionList`. We can then walk through all the registered SEH records in the SEH chain and observe how the last one is located at `0xffffffff` as discussed earlier:

![Walking through the SEH chain in WinDBG](../../../.gitbook/assets/teb-seh-chain.gif)

Note, however, that these SEH records are the exception handlers defined in the ntdll and not in our compiled binary:

![](../../../.gitbook/assets/image%20%28995%29.png)

In order to see the SEH records defined by our program, we need it to execute the try / catch code block that we have in the `main()` function. Let's see the CPU instructions at our program's entry point:

```text
u $exentry
```

![A bunch of jmp instructions in our seh-overflow.exe entry point](../../../.gitbook/assets/image%20%281000%29.png)

I do not know what the deal is with all the jmps, but let's try setting a break point at `00e1911d`, right after the first jmp at `00e19118`:

```text
bp $exentry + 5
g
```

![Breakpoint hit at the Image Entry](../../../.gitbook/assets/image%20%28996%29.png)

Let's now see where the SEH head is at:

![SEH chain starts at 00bbfb2c](../../../.gitbook/assets/image%20%28991%29.png)

Start of the SEH chain is located at `00bbfb2c`, so let's check the first SEH record:

```text
dt _EXCEPTION_REGISTRATION_RECORD 00bbfb2c
```

![](../../../.gitbook/assets/image%20%28979%29.png)

The exception handler for the first SEH record is at `0x00e220f0`. Let's see which module it belongs to:

```text
u 0x00e220f0
```

![0x00e220f0 is the 1st exception handler of seh-overflow.exe](../../../.gitbook/assets/image%20%28997%29.png)

The above image shows that `0x00e220f0` is inside our seh-overflow.exe image, meaning the SEH chain now contains our exception handler too.

We can more easily discover SEH records using xdbg, inspecting the SEH tab as shown below:

![Inspecting SEH chains using xdbg](../../../.gitbook/assets/image%20%28988%29.png)

Below shows how SEH records 1 to 4 \(right\) are organized on the program's stack \(left\):

![SEH chain on the stack](../../../.gitbook/assets/image%20%28984%29.png)

If we updated our very first diagram showing where SEH chain is located and how the SEH chain itself looks like with actual memory addresses, it would now look like this:

![TEB / TIB / SEH chain with actual memory addresses](../../../.gitbook/assets/image%20%281001%29.png)

Note that the exception handler at `0x00e220f0`, when we identified it previously using WinDbg after executing the first `jmp` inside the seh-overflow.exe entry point, was the first SEH record in the chain, however inspecting the SEH chain in xdbg, we can see that the handler `0x00e220f0` actually belongs to the second SEH record, which suggests that executing the first `jmp` was not enough to set up the full SEH chain. That, however, does not prevent us from moving this lab further to the exploitation phase, it's just something worth remember if you're playing along.

## Exploiting SEH Overflow

### Intro

We're going to be exploiting the [R 3.4.4](https://www.exploit-db.com/exploits/47122) on a 32-bit Windows 10 system.

{% hint style="info" %}
In order to keep the lab short and not repeat the information that can be found in my other notes, this lab will not go into details about the following:

* Identifying the overwrite offset - see [Finding EIP offset](stack-based-buffer-overflow.md#finding-eip-offset)
* Identifying bad characters for the shellcode - see [Finding bad characters](stack-based-buffer-overflow.md#finding-bad-characters)
{% endhint %}

### Confirming the Crash

Let's open RGUI.exe in xdbg and hit F9 as many times as you need in order to get the program's GUI to show up:

![RGUI showing up after launching it via xdbg](../../../.gitbook/assets/image%20%28994%29.png)

Let's generate some garbage that we will send to the RGUI in order to confirm we can crash it:

```python
python -c "print('A'*3000)" | clip.exe
```

![Generating garbage data using python](../../../.gitbook/assets/image%20%28987%29.png)

Open the RGUI configuration editor and paste the garbage data generated into the "Language for menus and messages" input box as shown and click OK and OK:

![Sending garbage data to RGUI to confirm we can crash it and check if it&apos;s vulnerable to overflows](../../../.gitbook/assets/crashing-rgui.gif)

At this point, looking at xdbg, we can confirm the program crashed and is vulnerable to a classic buffer overflow as we were able to overwrite the EIP register with our AAAA \(0x41414141\):

![Program is vulnerable to a classic buffer overflow - EIP is overwritten](../../../.gitbook/assets/image%20%28992%29.png)

More, importantly, however, we confirm that the program is also vulnerable to the SEH overflow by inspecting the SEH chain tab:

![Program confirmed to be vulnerable to SEH overflow - SEH record is overwrriten](../../../.gitbook/assets/image%20%281002%29.png)

Note from above screenshot that the first SEH record was overwritten in the following manner:

* SEH record's handler address was overwritten \(red\)
* Pointer to the next SEH record was also overwritten \(green\)

### Confirming SEH Record Offsets

When a user supplied input is sent to a program vulnerable with a buffer overflow vulnerability, the stack is overwritten from lower memory addresses towards higher memory addresses.

We also know that SEH records are stored on the stack and each one is an 8 byte memory structure that contains:

1. Pointer to the next SEH record;
2. Exception handler for the current SEH record.

Based on the above, in order to confirm the SEH record offsets:

1. Address to the next SEH record;
2. Address of the exception handler for the current SEH record;

...we should generate a dummy payload that is structured like so:

![](../../../.gitbook/assets/image%20%28989%29.png)

Following [Finding EIP offset](stack-based-buffer-overflow.md#finding-eip-offset) technique, we identity that the SEH record offset into the stack is `1012`.

Based on the new knowledge, our payload for testing if we can correctly overwrite the SEH record \(its pointer to the next SEH record and current SEH record's handler\), should now look like this:

![](../../../.gitbook/assets/image%20%28980%29.png)

Let's create the above payload:

```python
python -c "print('A'*1012 + 'BBBB' + 'CCCC')" | clip.exe
```

![](../../../.gitbook/assets/image%20%28993%29.png)

...and confirm we can overwrite the SEH record correctly:

![](../../../.gitbook/assets/image%20%28983%29.png)

From the above screenshote we can see that we can overwrite the SEH record correctly:

* 43434343 \(CCCC\) is the exception handler for the current SEH record
* 42424242 \(BBBB\) is the address of the next SEH record



## References

{% embed url="https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/" %}

{% embed url="https://docs.microsoft.com/en-us/cpp/build/reference/safeseh-image-has-safe-exception-handlers?view=msvc-160" %}



