# SEH Based Buffer Overflow

The purpose of this lab is to familiarize how Structured Exception Handler / SEH based buffer overflow exploits work.

This lab is based on a blog post [The Basics of Exploit Development 2: SEH Overflows](https://www.coalfire.com/the-coalfire-blog/march-2020/the-basics-of-exploit-development-2-seh-overflows) by Andy Bowden.

{% hint style="info" %}
WIP
{% endhint %}

## SEH 101

* Structured exception handling \(SEH\) is simply code in a program that is meant to handles such situations when the program throws some exception either due to a hardware or software issue and do something to resolve it;
* SEH code is located on the program's stack for each `try-catch` code block and each handler has its own stack frame;
* SEH is stored in stack as `EXCEPTION_REGISTRATION` structure \(also called as SEH record\) consisting of two 4 byte fields:
  * pointer to the next SEH record within the SEH chain;
  * pointer to the exception handler code - the `catch` part of the code block;
* A program may have multiple SEHs registered that are connected by a linked list, forming a SEH chain;
  * Once a program throws an exception, the OS runs through the SEH chain and attempts to find an apropriate exception handler;
  * If no suitable handler is found, a default OS handler is used from the bottom of the SEH chain. All SEH chains always end with a default Windows SEH record located at `FFFFFFFF`;
* SEH chain is stored in the Thread Environment Block \(TEB\) memory structure as the first member called Thread Information Block \(TIB\) and can be accessed via FS segment register `FS:[0x00]`;
* 64-bit applications are not vulnerable to SEH overflow as binaries are linked with safe exception handlers embedded in the PE file itself.
* 32-bit applications can be linked with `/SAFESEH` flag, which will produce a PE file with a table of safe exception handlers, assuming all modules are compatible with safe execption handling feature.

Below is a simplified diagram visualising some of the key points outlined above:

![TEB, SEH Chains, SEH Records visualised](../../../.gitbook/assets/image%20%28974%29.png)

## Exploring TEB / TIB / SEH Chains

### Memory Structures

Let's explore the key structures around SEH using WinDBG and confirm the key points mentioned in the SEH 101 section.

Thread Environment Block is a described in the OS as `_TEB` memory structure and can be inspected in WinDBG like so: 

```text
dt _teb
```

![Snippet of the \_TEB memory structure](../../../.gitbook/assets/image%20%28973%29.png)

As seen from the above screenshot, the TEB's first member is `_NT_TIB` \(Thread Information Block\) memory structure, which can be inspected like so:

```text
dt _NT_TIB
```

![TIB memory structure in WinDBG](../../../.gitbook/assets/image%20%28975%29.png)

As mentioned earlier, the first member inside the `_NT_TIB` structure is a pointer to `_EXCEPTION_REGISTRATION_RECORD` memory structure, which is the first SEH record / head of the SEH Chain linked list and can be inspected like so:

```text
dt _EXCEPTION_REGISTRATION_RECORD
```

![SEH record memory structure \_EXCEPTION\_REGISTRATION\_RECORD ](../../../.gitbook/assets/image%20%28976%29.png)

The first member of `_EXCEPTION_REGISTRATION_RECORD` is a pointer to the next SEH record and the second member is a pointer to the exception handler that is defined in the `_EXCEPTION_DISPOSITION` memory structure.

### Actual Memory Structures

We've learned about a couple of key memory structures, but now let's see how those structures look like when inspecting a real program that has some SEH records defined. 

As noted earlier, SEH are the `try` / `catch` code blocks in the program as shown below:

{% code title="seh-overflow.c" %}
```c
int main(int argc, char* argv[]) 
{
    try
    {
        throw 1;
    }
    catch (int e)
    {
        
    }

    return 0;
}
```
{% endcode %}

Let's compile the above program as seh-overflow.exe and inspect it with WinDBG again, this time with a `!teb` command:

![!teb](../../../.gitbook/assets/image%20%28978%29.png)

We can see that `_TEB` is located at `00a25000` and that the `ExceptionList` / head of the SEH chain is located at `00cff2cc`. From earlier, we said that this value could also be retrieved from the FS segment register `fs:[0]`, so let's confirm that:

```text
dd fs:[0] L1
```

![SEH chain retrieved from fs:\[0\]](../../../.gitbook/assets/image%20%28971%29.png)

Let's check the start of the SEH chain at `00cff2cc` like so:

```text
dt _EXCEPTION_REGISTRATION_RECORD 00cff2cc
```

{% hint style="info" %}
From this point the`ExceptionList` address changed from `00cff2cc` to `00cff274` due to the restarted program. This may happen multiple time throughout the labs.
{% endhint %}

![Start of the SEH chain at 00cff274](../../../.gitbook/assets/image%20%28981%29.png)

Below gif demonstrates how we can get the address of the head of the SEH chain with `!teb` command and by inspecting the `ExceptionList`. We can then walk through all the registered SEH records in the SEH chain and observe how the last one is located at `0xffffffff` as discussed earlier:

![Walking through the SEH chain in WinDBG](../../../.gitbook/assets/teb-seh-chain.gif)

Note, however, that these SEH records are the exception handlers defined in the ntdll and not in our compiled binary:

![](../../../.gitbook/assets/image%20%28984%29.png)

In order to see the SEH records defined by our program, we need it to execute the try / catch code block that we have in the `main()` function. Let's see the CPU instructions at our program's entry point:

```text
u $exentry
```

![A bunch of jmp instructions in our seh-overflow.exe entry point](../../../.gitbook/assets/image%20%28988%29.png)

I do not know what the deal is with all the jmps, but let's try setting a break point at `00e1911d`, right after the first jmp at `00e19118`:

```text
bp $exentry + 5
g
```

![Breakpoint hit at the Image Entry](../../../.gitbook/assets/image%20%28985%29.png)

Let's now see where the SEH head is at:

![SEH chain starts at 00bbfb2c](../../../.gitbook/assets/image%20%28983%29.png)

Start of the SEH chain is located at `00bbfb2c`, so let's check the first SEH record:

```text
dt _EXCEPTION_REGISTRATION_RECORD 00bbfb2c
```

![](../../../.gitbook/assets/image%20%28979%29.png)

The exception handler for the first SEH record is at `0x00e220f0`. Let's see which module it belongs to:

```text
u 0x00e220f0
```

![0x00e220f0 is the 1st exception handler of seh-overflow.exe](../../../.gitbook/assets/image%20%28986%29.png)

The above image shows that `0x00e220f0` is inside our seh-overflow.exe image, meaning the SEH chain now contains our exception handler too.

We can more easily discover SEH records using xdbg, inspecting the SEH tab as shown below:

![Inspecting SEH chains using xdbg](../../../.gitbook/assets/image%20%28982%29.png)

Below shows how SEH records 1 to 4 \(right\) are organized on the program's stack \(left\):

![SEH chain on the stack](../../../.gitbook/assets/image%20%28980%29.png)

If we updated our very first diagram showing where SEH chain is located and how the SEH chain itself looks like with actual memory addresses, it would now look like this:

![TEB / TIB / SEH chain with actual memory addresses](../../../.gitbook/assets/image%20%28989%29.png)

Note that the exception handler at `0x00e220f0`, when we identified it previously using WinDbg after executing the first `jmp` inside the seh-overflow.exe entry point, was the first SEH record in the chain, however inspecting the SEH chain in xdbg, we can see that the handler `0x00e220f0` actually belongs to the second SEH record, which suggests that executing the first `jmp` was not enough to set up the full SEH chain. That, however, does not prevent us from moving this lab further to the exploitation phase, it's just something worth remember if you're playing along.

## Exploiting SEH Overflow



## References

{% embed url="https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/" %}

{% embed url="https://docs.microsoft.com/en-us/cpp/build/reference/safeseh-image-has-safe-exception-handlers?view=msvc-160" %}



